import{T as A,U as E,g as l,h as s,i as h,j as m,J as C,V as i}from"./DsgVtOPg.js";import{A as $,g as N}from"./vycYFVnX.js";class D{#e=l(!1);get connected(){return s(this.#e)}set connected(e){h(this.#e,e,!0)}#t=l(!1);get connecting(){return s(this.#t)}set connecting(e){h(this.#t,e,!0)}#s=l(!1);get authenticated(){return s(this.#s)}set authenticated(e){h(this.#s,e,!0)}#n=l(null);get error(){return s(this.#n)}set error(e){h(this.#n,e,!0)}#a=l(m([]));get messages(){return s(this.#a)}set messages(e){h(this.#a,e,!0)}#r=l(m(new Map));get taskMessages(){return s(this.#r)}set taskMessages(e){h(this.#r,e,!0)}#o=l(m(new Set));get subscriptions(){return s(this.#o)}set subscriptions(e){h(this.#o,e,!0)}ws=null;url;reconnectTimer;heartbeatTimer;reconnectAttempts=0;get isReady(){return this.connected&&this.authenticated}get latestMessage(){return this.messages[this.messages.length-1]}constructor(e){this.url=e||$.websocket}connect(){if(typeof window>"u"||typeof WebSocket>"u"){console.warn("[WebSocket] ブラウザ環境ではありません。接続をスキップします。");return}if(this.connected||this.connecting||this.ws){console.log("[WebSocket] 既に接続中または接続済み",{connected:this.connected,connecting:this.connecting,hasWs:!!this.ws});return}this.connecting=!0,this.error=null;try{console.log("[WebSocket] 接続を開始します:",this.url),this.ws=new window.WebSocket(this.url),console.log("[WebSocket] WebSocket作成完了",{readyState:this.ws.readyState,url:this.ws.url}),this.ws.onopen=()=>this.handleOpen(),this.ws.onmessage=e=>this.handleMessage(e),this.ws.onerror=e=>this.handleError(e),this.ws.onclose=e=>this.handleClose(e)}catch(e){console.error("[WebSocket] 接続エラー:",e),this.connecting=!1,this.error=e instanceof Error?e:new Error("接続エラー")}}disconnect(){this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=void 0),this.stopHeartbeat(),this.ws&&(this.ws.close(1e3,"ユーザーによる切断"),this.ws=null),this.connected=!1,this.connecting=!1,this.authenticated=!1,this.subscriptions.clear()}send(e){if(!this.connected||!this.ws){console.error("WebSocket未接続");return}this.ws.send(JSON.stringify(e))}authenticate(){if(typeof window>"u"){console.warn("[WebSocket] ブラウザ環境ではありません。認証をスキップします。");return}const e=N();if(console.log("[WebSocket] 認証を開始",{hasApiKey:!!e}),!e){console.warn("[WebSocket] APIキーが設定されていません");const r="hoge";console.log("[WebSocket] デフォルトAPIキーを使用します");const c={type:"auth",payload:{apiKey:r}};this.send(c);return}const n={type:"auth",payload:{apiKey:e}};console.log("[WebSocket] 認証メッセージを送信",{type:n.type}),this.send(n)}subscribe(e){this.subscriptions.has(e)||(this.subscriptions.add(e),this.connected&&this.send({type:"subscribe",payload:{taskId:e}}))}unsubscribe(e){this.subscriptions.has(e)&&(this.subscriptions.delete(e),this.connected&&this.send({type:"unsubscribe",payload:{taskId:e}}))}getTaskMessages(e){return this.taskMessages.get(e)||[]}clearTaskMessages(e){const n=new Map(this.taskMessages);n.delete(e),this.taskMessages=n}handleOpen(){console.log("[WebSocket] 接続成功"),this.connected=!0,this.connecting=!1,this.reconnectAttempts=0,this.authenticate(),this.startHeartbeat(),this.subscriptions.forEach(e=>{this.send({type:"subscribe",payload:{taskId:e}})})}handleMessage(e){try{const n=JSON.parse(e.data),r=this.normalizeMessage(n);if(this.messages=[...this.messages,r],r.taskId){const c=this.taskMessages.get(r.taskId)||[];this.taskMessages=new Map(this.taskMessages).set(r.taskId,[...c,r])}console.log("[WebSocket] メッセージ受信:",r.type,r),r.type==="auth:success"&&(this.authenticated=!0,console.log("[WebSocket] 認証成功")),r.type==="auth:error"&&(this.authenticated=!1,console.error("[WebSocket] 認証失敗:",r.error)),r.type}catch(n){console.error("メッセージ解析エラー:",n)}}handleError(e){console.error("WebSocketエラー:",e),this.error=new Error("WebSocket接続エラー")}handleClose(e){console.log("WebSocket切断:",e.code,e.reason),this.connected=!1,this.connecting=!1,this.authenticated=!1,this.ws=null,this.stopHeartbeat(),e.code!==1e3&&e.code!==1001&&this.scheduleReconnect()}scheduleReconnect(){if(this.reconnectTimer)return;if(this.reconnectAttempts>=10){this.error=new Error("再接続の最大試行回数に達しました");return}this.reconnectAttempts++;const e=Math.min(5e3*Math.pow(2,this.reconnectAttempts-1),3e4);console.log(`${e}ms後に再接続を試みます（${this.reconnectAttempts}/10）`),this.reconnectTimer=window.setTimeout(()=>{this.reconnectTimer=void 0,this.ws=null,this.connect()},e)}startHeartbeat(){this.heartbeatTimer=window.setInterval(()=>{this.connected&&this.ws&&this.ws.readyState===WebSocket.OPEN&&this.send({type:"ping",payload:{}})},3e4)}stopHeartbeat(){this.heartbeatTimer&&(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0)}normalizeMessage(e){if(e.payload){const{type:n,payload:r}=e,{taskId:c,timestamp:f,...b}=r||{};return{type:n,taskId:c,data:b,timestamp:f||new Date().toISOString()}}else return{...e,timestamp:e.timestamp||new Date().toISOString()}}}const S=Symbol("websocket");function R(a){A(S,a)}function M(){const a=E(S);if(!a)throw new Error("WebSocketコンテキストが設定されていません");return a}function _(a){return new D(a)}function P(a){const e=M();C(()=>(e.subscribe(a),()=>{e.unsubscribe(a)}));const n=i(()=>e.getTaskMessages(a)),r=i(()=>s(n).filter(t=>["task:log","task:tool:start","task:tool:end","task:claude:response","task:todo_update"].includes(t.type)).map(t=>{switch(t.type){case"task:log":return t.data?.log||"";case"task:tool:start":return`🛠️ [${t.data?.tool}] 開始${t.data?.input?`: ${JSON.stringify(t.data.input).slice(0,100)}...`:""}`;case"task:tool:end":return`✅ [${t.data?.tool}] ${t.data?.success?"成功":"失敗"}${t.data?.duration?` (${t.data.duration}ms)`:""}`;case"task:claude:response":return`🤖 Claude: ${t.data?.text||""}`;case"task:todo_update":return t.data?.todos?`📝 TODO更新: ${t.data.todos.map(o=>`${o.content} [${o.status}]`).join(", ")}`:"📝 TODO更新";default:return JSON.stringify(t.data)}})),c=i(()=>s(n).filter(t=>t.type==="task:tool:start"||t.type==="task:tool:end").map(t=>({type:t.type,tool:t.data?.tool||"",args:t.data?.input,duration:t.data?.duration,success:t.data?.success,error:t.data?.error,timestamp:t.timestamp||new Date().toISOString()}))),f=i(()=>s(n).filter(t=>t.type==="task:claude:response").map(t=>({response:t.data?.text||"",turnNumber:t.data?.turnNumber,maxTurns:t.data?.maxTurns,timestamp:t.timestamp||new Date().toISOString()}))),b=i(()=>(()=>{const t=s(n).filter(g=>g.type==="task:statistics");if(t.length===0)return null;const o=t[t.length-1];return o.data?.statistics||o.data||null})()),W=i(()=>s(n).filter(t=>t.type==="task:todo_update").map(t=>t.data?.todos&&Array.isArray(t.data.todos)?t.data.todos.map(o=>({id:o.id,content:o.content||"",status:o.status||"",priority:o.priority||"medium",timestamp:t.timestamp||new Date().toISOString()})):[]).flat()),T=i(()=>(()=>{const t=s(n).filter(y=>y.type==="task:progress"),o=s(n).filter(y=>y.type==="task:claude:response"),g=o[o.length-1],w=g?.data?.turnNumber||0,k=g?.data?.maxTurns||0,p=t[t.length-1],d=p?.data?.progress?.phase||p?.data?.phase,x=p?.data?.progress?.message||p?.data?.message||"";let u=0;return d==="setup"?u=10:d==="planning"?u=20:d==="execution"?k>0?u=20+Math.min(60,w/k*60):u=50:d==="cleanup"?u=90:d==="complete"&&(u=100),{percent:u,message:x,turn:w,maxTurns:k,phase:d}})()),O=i(()=>(()=>{const t=s(n).filter(o=>["task:completed","task:failed","task:cancelled","task:update"].includes(o.type));return t.length===0?null:t[t.length-1]})());return{get connected(){return e.connected},get authenticated(){return e.authenticated},get messages(){return s(n)},get logs(){return s(r)},get toolExecutions(){return s(c)},get claudeResponses(){return s(f)},get statistics(){return s(b)},get todoUpdates(){return s(W)},get progress(){return s(T)},get statusChange(){return s(O)},clearMessages:()=>e.clearTaskMessages(a)}}function H(){const a=M();return{get connected(){return a.connected},get connecting(){return a.connecting},get authenticated(){return a.authenticated},get error(){return a.error},get isReady(){return a.isReady},connect:()=>a.connect(),disconnect:()=>a.disconnect()}}export{H as a,_ as c,R as s,P as u};
